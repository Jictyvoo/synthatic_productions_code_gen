import 'package:thenafter_dart/src/util/helpers/string_helper.dart';
import 'package:thenafter_dart/src/util/types_util.dart';

import 'token.dart';

/// Data class that holds all information parsed from a grammar
class GrammarInformation {
  // Known definitions
  /// The start symbol for a grammar
  final Token startSymbol;

  /// The grammar name
  final String name;

  /// The grammar authors
  final String author;

  /// The grammar version
  final String version;

  /// An about that tells general information about the grammar
  final String about;

  /// Shows if the grammar is case sensitive
  final bool caseSensitive;

  // Generated elements
  /// All productions generated by a grammar and how it produces all of them
  final ProductionsMap productions;

  /// Custom extra definitions
  final Map<String, String> extraDefinitions;

  /// Default constructor that store data for a grammar
  const GrammarInformation({
    required this.startSymbol,
    String? name,
    String? author,
    String? version,
    String? about,
    this.caseSensitive = true,
    this.extraDefinitions = const <String, String>{},
    this.productions = const <String, SubProductionsList>{},
  })  : author = author ?? 'Thenafter',
        name = name ?? 'Thenafter: Loaded.grm',
        version = version ?? 'v0.0.1',
        about = about ?? 'Generated with the help of Thenafter';

  Token _sanitizeToken(
    final Token token,
  ) {
    if (token.tokenType != TokenType.variableTerminal) {
      return token;
    }
    final toReplace = extraDefinitions[token.lexeme] ?? '';
    if (toReplace.isNotEmpty && !StringHelper.isRegex(toReplace)) {
      return token.copyWith(
        lexeme: "'$toReplace'",
        tokenType: TokenType.terminal,
      );
    }

    return token;
  }

  /// Returns a sanitized version of the productions map.
  ///
  /// Example usage:
  /// ```dart
  /// final sanitizedMap = instance.productionsSanitized;
  /// ```
  ProductionsMap get productionsSanitized {
    return {
      for (final entry in productions.entries)
        entry.key: [
          for (final subList in entry.value)
            [for (final token in subList) _sanitizeToken(token)]
        ]
    };
  }

  @override
  String toString() {
    return 'GrammarInformation{'
        'startSymbol: $startSymbol, name: $name, '
        'author: $author, version: $version, '
        'about: $about, caseSensitive: $caseSensitive'
        '}';
  }
}
